---
title: "Class 15"
author: "Tasnia Sharia (PID A15931128)"
date: "11/16/2021"
output:
  pdf_document: default
  html_document: default
---

# Background
Our data for today comes from the Himes et al. RNASeq analysis of the drug dexamethasone, a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014). 

# Import CountData and colData

Reading the CSV files
```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")

#Viewing the first 6 rows of the data
head(counts)
head(metadata)
```

> **Q1. How many genes are in this dataset?**

```{r}
# provides number of rows and columns
dim(counts)
```
There are 38694 genes in this dataset.


> **Q2. How many ‘control’ cell lines do we have?**

```{r}
sum(metadata$dex == "control")
```
There are 4 'control' cell lines.

# Toy differential gene expression

calculating the mean counts per gene across the control samples

```{r}
#only extracts the control samples
control <- metadata[metadata[,"dex"]=="control",]
#extracting data from the counts file
control.counts <- counts[ ,control$id]
#taking rowwise mean to get the average count values for all genes in these 4 experiments
control.mean <- rowSums( control.counts )/4 
head(control.mean)
```

```{r}
control.mean <- rowMeans(control.counts)
```


```{r}
#library(dplyr)
#control <- metadata %>% filter(dex=="control")
#control.counts <- counts %>% select(control$id) 
#control.mean <- rowSums(control.counts)/4
#head(control.mean)
```

> **Q3. How would you make the above code in either approach more robust?**

You can use rowMeans to make the code more robust.

> **Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)**

Now do the same for the drug treated experiments (i.e. columns)
```{r}
treated.inds <- metadata$dex=="treated"
treated.counts <- counts[ , treated.inds]
head(treated.counts)
treated.mean <- rowMeans(treated.counts)
```

We will combine our meancount data for bookkeeping purposes

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

> **Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples**

Let's make a quick plot

```{r}
plot(meancounts)
```

> **Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?**

Using ggplot2

```{r}
#getting the ggplot2 library
library(ggplot2)
ggplot(meancounts, aes(x=control.mean, y=treated.mean)) + geom_point()
```

> **Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?**

```{r}
plot(meancounts, log="xy")
```

We can find candidate differentially expressed genes by looking for genes with a large change between control and dex-treated samples.We often use log2 in this field because it has nice math properties that make interpretation easier

```{r}
#testing log2
log2(20/10)
log2(5/10)
```

We see 0 values for no change and plus values for increases and minus values for decreases.  This nice property lends us to work with **log2foldchange** all the time in the genomics and proteomics filed.

```{r}
#taking treated over control and taking the log2 of it
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

Let’s filter our data to remove the genes with Nan and -Inf

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> **Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?**

The arr.ind=TRUE argument will tell us which genes (rows) and samples (columns) have zero counts. We are going to ignore any genes that have zero counts in any sample so we just focus on the row answer. The unique() function will ensure we don't count any row twice if it has zero entries in both samples.


Let’s filter the dataset both ways to see how many genes are up or down-regulated.
 
```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```
 
 > **Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?**
 
```{r}
sum(up.ind == TRUE)
```
 
 > **Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?**
 
```{r}
sum(down.ind == TRUE)
```
 
 > **Q10. Do you trust these results? Why or why not?**
 
It is uncertain to tell since fold change can be large without being statistically significant (e.g. based on p-values). We have not done anything yet to determine whether the differences we are seeing are significant. 


# DESeq2 analysis

DESeq2 is an R package specifically for analyzing count-based NGS data like RNA-seq. It is available from Bioconductor. Bioconductor is a project to provide tools for analyzing high-throughput genomic data including RNA-seq, ChIP-seq and arrays.

```{r}
# loading DESeq2 library
library(DESeq2)
citation("DESeq2")
```

We will use the DESeqDataSetFromMatrix() function to build the required DESeqDataSet object and call it dds

```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```

Running the DESeq analysis pipeline on the dataset, and reassign the resulting object back to the same variable.

```{r}
#This function calls a number of other functions within the package to essentially run the entire pipeline
dds <- DESeq(dds)
```

We’ve got a simple design and can get results out of the object simply by calling the results() function on the DESeqDataSet that has been run through the pipeline.

```{r}
res <- results(dds)
res
```

```{r}
summary(res)
```

```{r}
#The results function contains a number of arguments to customize the results table
res05 <- results(dds, alpha=0.05)
summary(res05)
```

# Adding annotation data

Our result table so far only contains the Ensembl gene IDs. However, alternative gene names and extra annotation are usually required for informative interpretation of our results. In this section we will add this necessary annotation data to our results.

```{r}
#loading the libraries
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

We can use the mapIds() function to add individual columns to our results table

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
head(res)
```

> **Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.**

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

You can arrange and view the results by the adjusted p-value

```{r}
ord <- order( res$padj )

head(res[ord,])
```

Write out the ordered significant results with annotations

```{r}
write.csv(res[ord,], "deseq_results.csv")
```

# Data Visualization

We will be producing volcano plots, summary figures used to highlight the proportion of genes that are both significantly regulated and display a high fold change.

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```

Adding some guidelines and color

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```

```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

For more customization, the EnhancedVolcano bioconductor package useful. We will add the more understandable gene symbol names to our full results object res as we will use this to label the most interesting genes in our final plot.

```{r}
#loading the EnhancedVolcano library
library(EnhancedVolcano)

#making the volcano plot
x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```

# Pathway analysis

Pathway analysis (also known as gene set analysis or over-representation analysis), aims to reduce the complexity of interpreting gene lists via mapping the listed genes to known (i.e. annotated) biological pathways, processes and functions.

```{r}
#loading libraries
library(pathview)
library(gage)
library(gageData)

# gageData package has pre-compiled databases mapping genes to KEGG pathways and GO terms for common organisms.
data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```

```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

Let’s run the gage pathway analysis.

```{r}
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

```{r}
attributes(keggres)
```

```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```

Let’s try out the pathview() function from the pathview package to make a pathway plot with our RNA-Seq expression results shown in color.

```{r}
#installed and loaded pathview package
library(pathview)

pathview(gene.data=foldchanges, pathway.id="hsa05310")
```

```{r}
# A different PDF based output of the same data
pathview(gene.data=foldchanges, pathway.id="hsa05310", kegg.native=FALSE)
```


> **Q12. Can you do the same procedure as above to plot the pathview figures for the top 2 down-reguled pathways?**

Yes you can do the same procedure.
